import{_ as a,c as t,f as s,d as n,r as h,o as l}from"./app-CLUM5Ji-.js";const p={};function r(k,i){const e=h("Swiper");return l(),t("div",null,[i[0]||(i[0]=s('<h2 id="一、计算属性" tabindex="-1"><a class="header-anchor" href="#一、计算属性"><span>一、计算属性</span></a></h2><p>1、 使用本地图片在 <code>vuepress</code> 下面的静态资源 直接使用 <code>images/img.png</code></p><p>2、 网络链接图片直接使用</p><p>3、 本地图片非在 <code>vuepress</code> 下的图片,在全路径(绝对路经) <code>picture/img.png</code></p>',4)),n(e,{items:["images/img.png","https://test.hnnfs.com/html/img/index_bng.jpg","picture/img.png"]}),i[1]||(i[1]=s(`<h3 id="_1-计算属性-vs-侦听器" tabindex="-1"><a class="header-anchor" href="#_1-计算属性-vs-侦听器"><span>1.计算属性 vs 侦听器</span></a></h3><p>Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性。当你有一些数据需要随着其它数据变动而变动时，你很容易滥用 watch——特别是如果你之前使用过 AngularJS。然而，通常更好的做法是使用计算属性而不是命令式的 watch 回调。</p><h3 id="_2-计算属性-vs-方法" tabindex="-1"><a class="header-anchor" href="#_2-计算属性-vs-方法"><span>2.计算属性 vs 方法</span></a></h3><p>我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是<strong>计算属性是基于它们的响应式依赖进行缓存的</strong>。只在相关响应式依赖发生改变时它们才会重新求值。</p><h3 id="_3-依赖与注入-provide-和-inject" tabindex="-1"><a class="header-anchor" href="#_3-依赖与注入-provide-和-inject"><span>3.依赖与注入 provide 和 inject</span></a></h3><ul><li>provide 选项允许我们指定我们想要提供给后代组件的数据/方法</li></ul><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-js"><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">provide</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> function</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> ()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">  return</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">    getMap</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">getMap</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">  }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>inject 选项来接收指定的我们想要添加在这个实例上的 property</li></ul><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-js"><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">inject</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> [</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">getMap</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">];</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>注: 依赖注入还是有负面影响的。它将你应用程序中的组件与它们当前的组织方式耦合起来，使重构变得更加困难。同时所提供的 property 是非响应式的。</li></ul><h2 id="二、响应式原理" tabindex="-1"><a class="header-anchor" href="#二、响应式原理"><span>二、响应式原理</span></a></h2><h3 id="_1-对于对象" tabindex="-1"><a class="header-anchor" href="#_1-对于对象"><span>1.对于对象</span></a></h3><ul><li>Vue 无法检测 property 的添加或移除。由于 Vue 会在初始化实例时对 property 执行 getter/setter 转化，所以 property 必须在 data 对象上存在才能让 Vue 将它转换为响应式的。例如：</li><li>对于已经创建的实例，Vue 不允许动态添加根级别的响应式 property。但是，可以使用 Vue.set(object, propertyName, value) 方法向嵌套对象添加响应式 property。</li><li>有时你可能需要为已有对象赋值多个新 property，比如使用 Object.assign() 或 _.extend()。但是，这样添加到对象上的新 property 不会触发更新。在这种情况下，你应该用原对象与要混合进去的对象的 property 一起创建一个新的对象。</li></ul><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-js"><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// 代替 \`Object.assign(this.someObject, { a: 1, b: 2 })\`</span></span>
<span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">someObject</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> Object</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">assign</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">({},</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">someObject</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span><span style="--shiki-light:#998418;--shiki-dark:#B8A965;"> a</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#998418;--shiki-dark:#B8A965;"> b</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 2</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> });</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-对于数组" tabindex="-1"><a class="header-anchor" href="#_2-对于数组"><span>2.对于数组</span></a></h3><p>Vue 不能检测以下数组的变动：</p><ul><li>当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue</li><li>当你修改数组的长度时，例如：vm.items.length = newLength</li></ul><p>方法一</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-js"><span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">Vue</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">set</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">vm</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">items</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> indexOfItem</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> newValue</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>方法二</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-js"><span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">vm</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">items</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">splice</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">indexOfItem</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> newValue</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>`,21))])}const g=a(p,[["render",r]]),c=JSON.parse('{"path":"/before/6czvxm2x/","title":"vue","lang":"zh-CN","frontmatter":{"title":"vue","createTime":"2025/06/27 14:00:33","permalink":"/before/6czvxm2x/","description":"一、计算属性 1、 使用本地图片在 vuepress 下面的静态资源 直接使用 images/img.png 2、 网络链接图片直接使用 3、 本地图片非在 vuepress 下的图片,在全路径(绝对路经) picture/img.png 1.计算属性 vs 侦听器 Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性。当你有...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"vue\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-08-18T00:26:44.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://plus-wave.github.io/docs/before/6czvxm2x/"}],["meta",{"property":"og:site_name","content":"Lidon Blog"}],["meta",{"property":"og:title","content":"vue"}],["meta",{"property":"og:description","content":"一、计算属性 1、 使用本地图片在 vuepress 下面的静态资源 直接使用 images/img.png 2、 网络链接图片直接使用 3、 本地图片非在 vuepress 下的图片,在全路径(绝对路经) picture/img.png 1.计算属性 vs 侦听器 Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性。当你有..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-18T00:26:44.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-18T00:26:44.000Z"}]]},"readingTime":{"minutes":2.28,"words":684},"git":{"createdTime":1751258907000,"updatedTime":1755476804000},"autoDesc":true,"filePathRelative":"notes/interview/3.前端面试/4.Vue/vue.md","headers":[],"bulletin":true}');export{g as comp,c as data};
